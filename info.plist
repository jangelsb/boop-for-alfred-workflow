<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>bundleid</key>
	<string>com.jangelsb.boop</string>
	<key>category</key>
	<string>Productivity</string>
	<key>connections</key>
	<dict>
		<key>99CA1911-F083-4604-9D1A-D40DCD09B99E</key>
		<array>
			<dict>
				<key>destinationuid</key>
				<string>A5B9F109-9A50-4DE3-A6FC-F537819581E7</string>
				<key>modifiers</key>
				<integer>0</integer>
				<key>modifiersubtext</key>
				<string></string>
				<key>vitoclose</key>
				<false/>
			</dict>
		</array>
		<key>A5B9F109-9A50-4DE3-A6FC-F537819581E7</key>
		<array>
			<dict>
				<key>destinationuid</key>
				<string>E29FE0F5-96B7-44C0-B3C0-08AFB6944968</string>
				<key>modifiers</key>
				<integer>0</integer>
				<key>modifiersubtext</key>
				<string></string>
				<key>vitoclose</key>
				<false/>
			</dict>
		</array>
		<key>A6E0859A-C7A2-4944-8503-1D5890712F8A</key>
		<array/>
		<key>D09DD5A9-46D1-4F23-A285-F7A85537551A</key>
		<array>
			<dict>
				<key>destinationuid</key>
				<string>99CA1911-F083-4604-9D1A-D40DCD09B99E</string>
				<key>modifiers</key>
				<integer>0</integer>
				<key>modifiersubtext</key>
				<string></string>
				<key>vitoclose</key>
				<false/>
			</dict>
		</array>
	</dict>
	<key>createdby</key>
	<string>Josh Angelsberg &amp; Ivan Mathy</string>
	<key>description</key>
	<string>The ability to run text actions</string>
	<key>disabled</key>
	<false/>
	<key>name</key>
	<string>Boop</string>
	<key>objects</key>
	<array>
		<dict>
			<key>config</key>
			<dict>
				<key>autopaste</key>
				<false/>
				<key>clipboardtext</key>
				<string>{query}</string>
				<key>ignoredynamicplaceholders</key>
				<false/>
				<key>transient</key>
				<false/>
			</dict>
			<key>type</key>
			<string>alfred.workflow.output.clipboard</string>
			<key>uid</key>
			<string>E29FE0F5-96B7-44C0-B3C0-08AFB6944968</string>
			<key>version</key>
			<integer>3</integer>
		</dict>
		<dict>
			<key>config</key>
			<dict>
				<key>concurrently</key>
				<false/>
				<key>escaping</key>
				<integer>68</integer>
				<key>script</key>
				<string>ObjC.import("stdlib")

function run(argv) {
  var query = $.getenv("input")

  // State object to pass to the `main` function
  var state = {
    text: query,
    fullText: query,
    selection: query,
    postError: function (message) {
      throw new Error(message); // Throw errors if invalid JSON
    },
  };

  try {
    // Inject the custom `require` function
    var require = createRequire();

    // Load the external script
    var scriptPath = $.getenv("input_script_path")
    var scriptContent = readFile(scriptPath);

    // Debug: Check the script content
    if (scriptContent) {
      console.log("Script content loaded successfully.");
    } else {
      console.log("Script content is empty or undefined.");
    }

    // Wrap the script content in a function that has access to `require` and exposes `main`
    var wrappedScript = `
      (function(require, state) {
        ${scriptContent}
        if (typeof main !== 'function') {
          throw new Error("The script did not define a 'main' function.");
        }
        // Expose main globally
        this.main = main;
      })(require, state);
    `;

    // Execute the wrapped script
    eval(wrappedScript);

    // Check if the main function was defined
    if (typeof main === "function") {
      main(state); // Call the main function with the state object
    } else {
      throw new Error("The script did not define the 'main' function.");
    }

    // Return the formatted text
    return state.text;
  } catch (error) {
    // Return an error message if something goes wrong
    return "Error: " + error.message;
  }
}

// Custom `require` implementation
function createRequire() {
  return function (modulePath) {
    // Replace `@boop/` with the `scripts/lib` path
    if (modulePath.startsWith("@boop/")) {
      modulePath = "./scripts/lib/" + modulePath.substring(6) + ".js";
    } else if (!modulePath.endsWith(".js")) {
      modulePath += ".js";
    }

    // Read the module file
    var scriptContent = readFile(modulePath);

    if (!scriptContent) {
      throw new Error("Module not found: " + modulePath);
    }

    // Wrap the code in CommonJS-like structure
    var module = { exports: {} };

    var wrappedCode = `
      (function (exports, module) {
        ${scriptContent}
      })(module.exports, module);
    `;

    // Evaluate the wrapped code
    eval(wrappedCode);

    // Return the module's exports
    return module.exports;
  };
}

// Function to read file content
function readFile(filePath) {
  var app = Application.currentApplication();
  app.includeStandardAdditions = true;

  try {
    // Use a shell command to read the file content
    var result = app.doShellScript("cat " + filePath);
    return result; // Return the content of the file
  } catch (error) {
    throw new Error("Unable to read file at: " + filePath);
  }
}</string>
				<key>scriptargtype</key>
				<integer>1</integer>
				<key>scriptfile</key>
				<string></string>
				<key>type</key>
				<integer>7</integer>
			</dict>
			<key>type</key>
			<string>alfred.workflow.action.script</string>
			<key>uid</key>
			<string>A5B9F109-9A50-4DE3-A6FC-F537819581E7</string>
			<key>version</key>
			<integer>2</integer>
		</dict>
		<dict>
			<key>config</key>
			<dict>
				<key>argument</key>
				<string></string>
				<key>passthroughargument</key>
				<false/>
				<key>variables</key>
				<dict>
					<key>input</key>
					<string>{clipboard}</string>
					<key>input_script_path</key>
					<string>{query}</string>
				</dict>
			</dict>
			<key>type</key>
			<string>alfred.workflow.utility.argument</string>
			<key>uid</key>
			<string>99CA1911-F083-4604-9D1A-D40DCD09B99E</string>
			<key>version</key>
			<integer>1</integer>
		</dict>
		<dict>
			<key>config</key>
			<dict>
				<key>alfredfiltersresults</key>
				<false/>
				<key>alfredfiltersresultsmatchmode</key>
				<integer>3</integer>
				<key>argumenttreatemptyqueryasnil</key>
				<true/>
				<key>argumenttrimmode</key>
				<integer>0</integer>
				<key>argumenttype</key>
				<integer>1</integer>
				<key>escaping</key>
				<integer>102</integer>
				<key>keyword</key>
				<string>{var:input_keyword}</string>
				<key>queuedelaycustom</key>
				<integer>3</integer>
				<key>queuedelayimmediatelyinitially</key>
				<true/>
				<key>queuedelaymode</key>
				<integer>0</integer>
				<key>queuemode</key>
				<integer>1</integer>
				<key>runningsubtext</key>
				<string>Loading...</string>
				<key>script</key>
				<string>python3 process_url_script_filter.py "$1"</string>
				<key>scriptargtype</key>
				<integer>1</integer>
				<key>scriptfile</key>
				<string></string>
				<key>subtext</key>
				<string></string>
				<key>title</key>
				<string>Text Actions</string>
				<key>type</key>
				<integer>0</integer>
				<key>withspace</key>
				<true/>
			</dict>
			<key>type</key>
			<string>alfred.workflow.input.scriptfilter</string>
			<key>uid</key>
			<string>D09DD5A9-46D1-4F23-A285-F7A85537551A</string>
			<key>version</key>
			<integer>3</integer>
		</dict>
		<dict>
			<key>config</key>
			<dict>
				<key>taskuid</key>
				<string>com.alfredapp.automation.core/macOS/clipboard.export</string>
			</dict>
			<key>type</key>
			<string>alfred.workflow.automation.task</string>
			<key>uid</key>
			<string>887DF873-BF6E-4C65-895A-116A6CE73A8D</string>
			<key>version</key>
			<integer>1</integer>
		</dict>
		<dict>
			<key>config</key>
			<dict>
				<key>argument</key>
				<string>import json
import urllib.parse

def pretty_print_json(data):
    """Pretty print JSON data."""
    print(json.dumps(data, indent=4, sort_keys=True))

def url_encode(data):
    """URL encode a given string."""
    return urllib.parse.quote(data)

def url_decode(encoded_data):
    """URL decode a given encoded string."""
    return urllib.parse.unquote(encoded_data)

def trim_whitespace(data):
    """Trim whitespace from a string."""
    return data.strip()</string>
				<key>cleardebuggertext</key>
				<false/>
				<key>processoutputs</key>
				<true/>
			</dict>
			<key>type</key>
			<string>alfred.workflow.utility.debug</string>
			<key>uid</key>
			<string>C08DF74C-AAFB-4F41-985F-50D8DB7425D2</string>
			<key>version</key>
			<integer>1</integer>
		</dict>
		<dict>
			<key>config</key>
			<dict>
				<key>argument</key>
				<string>{
  "employees": [
    {
          "id": 1,
      "name": "Alice",
      "age": 30,
      "email": "alice@example.com",
      "department": "Engineering"
    },
    {
          "id": 2,
      "name": "Bob",
      "age": 25,
      "email": "bob@example.com",
      "department": "Marketing"
    },
    {
      "id": 3,
      "name": "Charlie",
      "age": 35,
      "email": "charlie@example.com",
      "department": "Sales"
    }
  ],
  "company": {
    "name": "TechCorp",
    "location": "New York",
    "founded": 2010
  },
  "is_public": true
}
</string>
				<key>passthroughargument</key>
				<false/>
				<key>variables</key>
				<dict/>
			</dict>
			<key>type</key>
			<string>alfred.workflow.utility.argument</string>
			<key>uid</key>
			<string>A6E0859A-C7A2-4944-8503-1D5890712F8A</string>
			<key>version</key>
			<integer>1</integer>
		</dict>
	</array>
	<key>readme</key>
	<string># AutoTagger

For more info check out the repo: https://github.com/jangelsb/auto-tagger-alfred-workflow

## üìñ Installation

### Step 1: Set up your Tags
```yaml
work üìÅ:
  - work
  - ios
  - pr

review üëÄ:
  - pr
  - doc
  - review

Card üí°:
  - create card

Important üî∫:
  - '!!'

```

### Step 2: Set up your URL Schemes
```yaml
- title: "Add to inbox üì•" 
  url: sorted://x-callback-url/add?title=[query]&amp;tags=[tags]&amp;date=[today]

- title: "Add to admin üìÅ" 
  url: sorted://x-callback-url/add?title=[query]&amp;tags=[tags]&amp;date=[today]&amp;list=%F0%9F%93%81%20Admin

- title: "Search in Sorted¬≥"
  url: sorted://x-callback-url/open?search=[query]
  icon: search.png

```

**Dyanmic variables:**
- `[query]`
- `[tags]`
- `[today]`

**Built in icons:**
- `tags.png`
- `search.png`

---

## üìù Version History

#### v2025.4
* Cleaned up workflow configuration to reference the readme
* Fixed typos

---

#### v2025.3
* Fixed issue with tags auto completing
* Removed subtitle for items in script filter
* Tweak how tags look in the UI
* Minor clean up

---

#### v2025.2
Now you can have multiple url schemes and see found tags in line!

* Changed workflow to use a script filter
* Added support for multiple url schemes in a yaml config
* Added some icons

---

#### v2025.1
This is the initial release.

The workflow defaults to working with Sorted¬≥ out of the box, but it can be customized to use any URL scheme üòä

It allows you to

* specify the tags and related terms in an inline yaml config
* specify the URL scheme with dynamic placeholders [title], [tags], [today]
the keyword
* Tags are added based on the items show up in the query. URLs are ignored.</string>
	<key>uidata</key>
	<dict>
		<key>887DF873-BF6E-4C65-895A-116A6CE73A8D</key>
		<dict>
			<key>xpos</key>
			<real>995</real>
			<key>ypos</key>
			<real>260</real>
		</dict>
		<key>99CA1911-F083-4604-9D1A-D40DCD09B99E</key>
		<dict>
			<key>xpos</key>
			<real>430</real>
			<key>ypos</key>
			<real>115</real>
		</dict>
		<key>A5B9F109-9A50-4DE3-A6FC-F537819581E7</key>
		<dict>
			<key>note</key>
			<string>Requried variables
`input`
`input_script_path`

Outputs the content of the script</string>
			<key>xpos</key>
			<real>570</real>
			<key>ypos</key>
			<real>75</real>
		</dict>
		<key>A6E0859A-C7A2-4944-8503-1D5890712F8A</key>
		<dict>
			<key>xpos</key>
			<real>95</real>
			<key>ypos</key>
			<real>495</real>
		</dict>
		<key>C08DF74C-AAFB-4F41-985F-50D8DB7425D2</key>
		<dict>
			<key>xpos</key>
			<real>770</real>
			<key>ypos</key>
			<real>410</real>
		</dict>
		<key>D09DD5A9-46D1-4F23-A285-F7A85537551A</key>
		<dict>
			<key>xpos</key>
			<real>75</real>
			<key>ypos</key>
			<real>145</real>
		</dict>
		<key>E29FE0F5-96B7-44C0-B3C0-08AFB6944968</key>
		<dict>
			<key>xpos</key>
			<real>770</real>
			<key>ypos</key>
			<real>70</real>
		</dict>
	</dict>
	<key>userconfigurationconfig</key>
	<array>
		<dict>
			<key>config</key>
			<dict>
				<key>default</key>
				<string>a</string>
				<key>placeholder</key>
				<string>a</string>
				<key>required</key>
				<true/>
				<key>trim</key>
				<true/>
			</dict>
			<key>description</key>
			<string>Type this phrase to add items</string>
			<key>label</key>
			<string>keyword</string>
			<key>type</key>
			<string>textfield</string>
			<key>variable</key>
			<string>input_keyword</string>
		</dict>
		<dict>
			<key>config</key>
			<dict>
				<key>default</key>
				<string>- title: Format JSON
  url: '1'

- title: URL Decode Text
  url: '2'

- title: URL Encode Text
  url: '3'

- title: Trim Whitespace
  url: '4'</string>
				<key>required</key>
				<true/>
				<key>trim</key>
				<true/>
				<key>verticalsize</key>
				<integer>9</integer>
			</dict>
			<key>description</key>
			<string>This a yaml config of actions, where each item has a title, url, and (optional) icon path.

See example in Step 2 üëâ</string>
			<key>label</key>
			<string>Actions</string>
			<key>type</key>
			<string>textarea</string>
			<key>variable</key>
			<string>input_url_scheme_list</string>
		</dict>
	</array>
	<key>variablesdontexport</key>
	<array/>
	<key>version</key>
	<string>0.2</string>
	<key>webaddress</key>
	<string>https://jangelsb.github.io</string>
</dict>
</plist>
